{
  "phase": 46,
  "question": "Q5",
  "summary": {
    "question": "Q5 (Automatic Commutativity Detection)",
    "status": "ANSWERED",
    "answer": "DECIDABLE for restricted languages, UNDECIDABLE for Turing-complete",
    "key_results": [
      "Undecidability Theorem: General commutativity is undecidable (Rice's Theorem)",
      "Decidable Fragments Theorem: Specific language classes ARE decidable",
      "Connection Theorem: Commutativity implies Liftability",
      "DETECT_COMMUTATIVE algorithm: Practical detection for common cases",
      "Validation: 10/13 test cases passed (76.9%)"
    ],
    "decidability_hierarchy": [
      "Level 0: Trivially decidable (constants, identity)",
      "Level 1: Decidable polynomial (finite state, CRDTs)",
      "Level 2: Decidable exponential (algebraic, bounded dataflow)",
      "Level 3: Decidable high complexity (FOL decidable theories, SQL)",
      "Level 4: Semi-decidable (can confirm, not always refute)",
      "Level 5: Undecidable (general programs)"
    ],
    "new_questions": [
      "Q176",
      "Q177",
      "Q178",
      "Q179",
      "Q180"
    ],
    "completes": "Automation pipeline from Phase 43",
    "open_since": "Phase 14"
  },
  "theorems": {
    "undecidability": {
      "name": "Commutativity Undecidability Theorem",
      "statement": "\nTHEOREM: For Turing-complete programming languages, the problem\n\"Given functions f and g, does f(g(x)) = g(f(x)) for all x?\"\nis UNDECIDABLE.\n\nCOROLLARY: There is no algorithm that can correctly determine\ncommutativity for ALL pairs of functions in a Turing-complete language.\n",
      "proof": "\nPROOF (via Rice's Theorem):\n\n1. Rice's Theorem states: For any non-trivial semantic property P\n   of programs, determining whether a program has property P is undecidable.\n\n2. \"Commutativity\" is a semantic property:\n   - It depends on the INPUT-OUTPUT behavior of functions\n   - Not on their syntactic structure\n   - Two syntactically different programs can have the same commutativity\n\n3. \"Commutativity\" is non-trivial:\n   - Some function pairs ARE commutative (e.g., addition)\n   - Some function pairs are NOT commutative (e.g., string concat)\n   - Therefore, the property is neither always true nor always false\n\n4. By Rice's Theorem, commutativity is UNDECIDABLE for Turing-complete languages.\n\nALTERNATIVE PROOF (via Halting Problem reduction):\n\nGiven: Halting problem decider H(P, x) = \"Does P halt on x?\"\n\nConstruct: For any program P and input x, define:\n  f_P(y) = { y     if P halts on x\n           { loop  otherwise }\n\n  g(y) = y + 1\n\nThen f_P and g commute IFF P halts on x.\nIf we could decide commutativity, we could decide halting. Contradiction.\n\nQED\n",
      "implications": [
        "No perfect commutativity detector exists for general programs",
        "Must restrict to decidable fragments for practical detection",
        "Heuristics and approximations are necessary for general code",
        "This is a FUNDAMENTAL limit, not a technology gap"
      ]
    },
    "decidable_fragments": {
      "name": "Decidable Fragments Theorem",
      "statement": "\nTHEOREM: Commutativity detection is DECIDABLE for the following language classes:\n\n1. FINITE STATE OPERATIONS\n   - Operations on finite domains\n   - Can enumerate all inputs and check\n\n2. ALGEBRAIC SPECIFICATIONS\n   - Operations defined by equations\n   - Can use equational reasoning\n\n3. SQL QUERIES (restricted)\n   - Queries without side effects\n   - Can analyze query plans\n\n4. CRDT SPECIFICATIONS\n   - Merge functions by definition\n   - CAI properties are checkable\n\n5. FIRST-ORDER LOGIC (decidable fragments)\n   - Quantifier-free formulas\n   - Some decidable theories (Presburger arithmetic, etc.)\n\n6. DATAFLOW OPERATIONS\n   - Pure functions on data\n   - Can use symbolic execution on bounded inputs\n",
      "proof_sketches": {
        "finite_state": "\nFor operations on finite domain D:\n1. Enumerate all pairs (a, b) in D x D\n2. Check if f(g(a, b)) = g(f(a, b)) for all pairs\n3. Complexity: O(|D|^2) - decidable in finite time\n",
        "algebraic": "\nFor algebraic specifications with equations E:\n1. The word problem for E determines commutativity\n2. For many equational theories, word problem is decidable\n3. Use Knuth-Bendix completion or similar\n4. Decidable for: groups, rings, lattices, semilattices\n",
        "sql": "\nFor SQL queries Q1, Q2 without side effects:\n1. Parse into relational algebra\n2. Check if R(Q1(Q2(T))) = R(Q2(Q1(T))) for all tables T\n3. Use query equivalence checking (decidable for core SQL)\n4. Many practical cases are decidable\n",
        "crdt": "\nFor CRDT merge functions:\n1. CRDTs are DEFINED to have commutative merge\n2. Check: merge(a, merge(b, c)) = merge(b, merge(a, c))\n3. This is a syntactic/type check, not semantic\n4. Always decidable (it's part of the CRDT contract)\n",
        "first_order": "\nFor first-order formulas in decidable theories:\n1. Presburger arithmetic: decidable\n2. Theory of real closed fields: decidable\n3. Some array theories: decidable\n4. Use SMT solvers (Z3, CVC5) for practical checking\n"
      },
      "hierarchy": "\nDECIDABILITY HIERARCHY FOR COMMUTATIVITY:\n\nLevel 0: TRIVIALLY DECIDABLE\n  - Constants (always commute with everything)\n  - Identity function (always commutes)\n\nLevel 1: DECIDABLE (polynomial time)\n  - Finite state operations\n  - CRDT merge functions\n  - Semilattice operations\n\nLevel 2: DECIDABLE (exponential time)\n  - Algebraic specifications (word problem)\n  - Bounded dataflow\n  - Quantifier-free first-order logic\n\nLevel 3: DECIDABLE (high complexity)\n  - Full first-order logic (decidable theories)\n  - SQL query equivalence\n\nLevel 4: SEMI-DECIDABLE\n  - Can confirm commutativity (find proof)\n  - Cannot always refute (may loop)\n\nLevel 5: UNDECIDABLE\n  - General Turing-complete programs\n  - Higher-order functions\n  - Programs with side effects\n"
    },
    "connection_to_liftability": {
      "name": "Commutativity-Liftability Connection Theorem",
      "statement": "\nTHEOREM (Commutativity-Liftability Connection):\n\n1. IMPLICATION: Commutative => Liftable\n   If operation O is commutative, then O is liftable (CC_0).\n\n2. NOT EQUIVALENCE: Liftable =/=> Commutative\n   Some liftable operations are not commutative.\n\n3. CAI SUFFICIENCY: CAI => Liftable\n   Commutative + Associative + Idempotent merge => Liftable\n\n4. DETECTION HIERARCHY:\n   Detect Commutative => Know Liftable (sufficient condition)\n   Detect Liftable => May not know Commutative (necessary for CRDT)\n",
      "proof": "\nPROOF:\n\n1. Commutative => Liftable:\n   - If f(a, b) = f(b, a) for all a, b\n   - Then order of operations doesn't matter\n   - Can be computed without coordination (CC_0)\n   - By Phase 41: This is existential verification\n   - Therefore liftable\n\n2. Liftable =/=> Commutative:\n   - Counter-example: LWW-Register\n   - LWW merge: merge(a, b) = (a.val, a.ts) if a.ts > b.ts else (b.val, b.ts)\n   - This is LIFTABLE (existential: \"most recent value exists\")\n   - But NOT commutative in general (depends on timestamps)\n   - The RESULT is deterministic, but the FUNCTION isn't symmetric\n\n3. CAI => Liftable:\n   - Commutative: order doesn't matter\n   - Associative: grouping doesn't matter\n   - Idempotent: duplicates don't matter\n   - Together: arbitrary merge order is safe\n   - This is the CRDT definition\n\n4. Detection Hierarchy:\n   - CLASSIFY (Phase 43) detects liftability\n   - Commutativity detection is STRONGER\n   - If we detect commutativity, we KNOW it's liftable\n   - If CLASSIFY says liftable, we still might need to check commutativity\n     for CRDT design\n\nQED\n",
      "practical_implications": [
        "Commutativity detection is SUFFICIENT for liftability",
        "But liftability detection (CLASSIFY) is more general",
        "For CRDT design, need full CAI check, not just liftability",
        "Use commutativity detection as a FAST PATH to liftability"
      ]
    }
  },
  "classify_connection": {
    "name": "DETECT_COMMUTATIVE and CLASSIFY Connection",
    "relationship": "\nPHASE 43: CLASSIFY\n  - Detects: Existential vs Universal verification\n  - Purpose: Determine liftability\n  - Basis: Phase 41 Liftability Theorem\n\nPHASE 46: DETECT_COMMUTATIVE\n  - Detects: Commutativity of operations\n  - Purpose: Determine coordination requirements at source\n  - Basis: Algebraic properties\n\nCONNECTION:\n\n  Commutative  =====>  Liftable\n       |                  |\n       v                  v\n  DETECT_COMMUTATIVE  CLASSIFY\n       |                  |\n       v                  v\n  (Decidable for       (Decidable for\n   restricted langs)    restricted specs)\n\nIf DETECT_COMMUTATIVE returns True:\n  - Operation is definitely liftable (CC_0)\n  - CLASSIFY would return EXISTENTIAL\n  - Can use CRDT implementation\n\nIf DETECT_COMMUTATIVE returns False:\n  - Need to check with CLASSIFY\n  - Might still be liftable (non-commutative but existential)\n  - Example: LWW-Register is liftable but not commutative in standard sense\n",
    "combined_algorithm": "\nCOMBINED_DETECTION(operation):\n    # Try fast path: commutativity\n    comm_result = DETECT_COMMUTATIVE(operation)\n\n    if comm_result.is_commutative == True:\n        return \"CC_0 (via commutativity)\"\n\n    # Fall back to liftability check\n    classify_result = CLASSIFY(operation)  # From Phase 43\n\n    if classify_result == EXISTENTIAL:\n        return \"CC_0 (via existential verification)\"\n    else:\n        return \"CC_log (requires coordination)\"\n",
    "advantages": [
      "Commutativity is often easier to detect than general liftability",
      "Provides fast path for common cases",
      "Combines syntactic (DETECT) and semantic (CLASSIFY) analysis",
      "Maximizes automation coverage"
    ]
  },
  "validation": [
    {
      "spec": "sum(a, b)",
      "expected": true,
      "detected": true,
      "confidence": 0.7,
      "method": "pattern_matching_heuristic",
      "passed": true
    },
    {
      "spec": "max(x, y)",
      "expected": true,
      "detected": true,
      "confidence": 0.95,
      "method": "algebraic_pattern_matching",
      "passed": true
    },
    {
      "spec": "SELECT COUNT(*) FROM users",
      "expected": true,
      "detected": true,
      "confidence": 0.99,
      "method": "sql_analysis",
      "passed": true
    },
    {
      "spec": "G-Counter increment",
      "expected": true,
      "detected": true,
      "confidence": 1.0,
      "method": "crdt_specification",
      "passed": true
    },
    {
      "spec": "OR-Set add",
      "expected": true,
      "detected": true,
      "confidence": 1.0,
      "method": "crdt_specification",
      "passed": true
    },
    {
      "spec": "union(set1, set2)",
      "expected": true,
      "detected": true,
      "confidence": 0.85,
      "method": "crdt_pattern_analysis",
      "passed": true
    },
    {
      "spec": "subtract(a, b)",
      "expected": false,
      "detected": null,
      "confidence": 0.0,
      "method": "algebraic_pattern_matching",
      "passed": false
    },
    {
      "spec": "division(a, b)",
      "expected": false,
      "detected": null,
      "confidence": 0.1,
      "method": "pattern_matching_heuristic",
      "passed": false
    },
    {
      "spec": "concat(str1, str2)",
      "expected": false,
      "detected": false,
      "confidence": 0.7,
      "method": "pattern_matching_heuristic",
      "passed": true
    },
    {
      "spec": "INSERT INTO log VALUES (now())",
      "expected": false,
      "detected": false,
      "confidence": 0.8,
      "method": "sql_analysis",
      "passed": true
    },
    {
      "spec": "append(list, item)",
      "expected": false,
      "detected": false,
      "confidence": 0.7,
      "method": "pattern_matching_heuristic",
      "passed": true
    },
    {
      "spec": "UPDATE users SET x = x + 1",
      "expected": null,
      "detected": false,
      "confidence": 0.8,
      "method": "sql_analysis",
      "passed": false
    },
    {
      "spec": "complex_function(a, b, state)",
      "expected": null,
      "detected": null,
      "confidence": 0.1,
      "method": "pattern_matching_heuristic",
      "passed": true
    }
  ],
  "validation_accuracy": 0.7692307692307693,
  "new_questions": [
    [
      "Q176",
      "SMT-based commutativity verification",
      "HIGH",
      "Can SMT solvers (Z3, CVC5) verify commutativity for larger program fragments?"
    ],
    [
      "Q177",
      "Commutativity for concurrent data structures",
      "HIGH",
      "How do we detect commutativity for lock-free and concurrent data structures?"
    ],
    [
      "Q178",
      "Approximate commutativity",
      "MEDIUM",
      "If operations 'almost' commute, can we quantify the approximation?"
    ],
    [
      "Q179",
      "Learning commutativity from examples",
      "MEDIUM",
      "Can ML learn commutativity patterns from execution traces?"
    ],
    [
      "Q180",
      "Commutativity-preserving transformations",
      "HIGH",
      "What program transformations preserve commutativity?"
    ]
  ]
}